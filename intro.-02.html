<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <!-- charset must remain utf-8 to be handled properly by Processing -->
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="user-scalable=no,width=1024px" />

    <title>The Stylogical Map [INTRO]</title>

<link rel="stylesheet" type="text/css" href='styles/mapscripts.css'></link>

<script type='text/javascript' src='scripts/jquery.1.4.x.min.js'></script>

<script type='text/javascript' src='scripts/debugger.js'></script>
<script type='text/javascript'>
/* Onload: */
var canvasApp=[], drawLoop=[], drawVideo=[], recordGIF={};
var aplayed=0, vplayed=0, adrawing=false, vdrawing=false;

$(function () { 
if (typeof window.addEventListener === 'function') {
  window.addEventListener("load", function init_page() {
    //alert('Start canvasApp');
    if (typeof canvasApp[0] !== 'undefined') {
      for(var i=0,z=canvasApp.length; i<z/*>*/;i++) {
        setTimeout(canvasApp[i],66);
      }
    } else {
      setTimeout(canvasApp,66);
    }
  }, false);
}
});

/* Processing Initializer: 
* Swiped from https://github.com/annasob/processing-js
* This code searches for all the &lt;script type="application/processing" target="canvasid"&gt;
* in your page and loads each script in the target canvas with the proper id.
* It is useful to smooth the process of adding Processing code in your page 
* and starting the Processing.js engine.
*/
var processing = {};
processing = 'undefined';

function init_processing() {
  if (typeof window.addEventListener === 'function') {
    window.addEventListener("load", function() {
      var scripts = document.getElementsByTagName("script");
      var canvasArray = Array.prototype.slice.call(document.getElementsByTagName("canvas"));
      var canvas;
      for (var i = 0, j = 0; i < scripts.length; i++) {
        if (scripts[i].type == "application/processing") {
          var src = scripts[i].getAttribute("target");
          if (src) {
            //alert("Processing target = "+ src);
            canvas = document.getElementById(src);
            if (canvas) {
              processing = new Processing(canvas, scripts[i].text);
              //alert("Processing started");
              for (var k = 0; k< canvasArray.length; k++)
              {
                if (canvasArray[k] === canvas) {
                  // remove the canvas from the array so we dont override it in the else
                  canvasArray.splice(k,1);
                }
              }
            }
          } else {   
            if (canvasArray.length >= j) {
              processing = new Processing(canvasArray[j], scripts[i].text);
              //alert("Processing started");
            }
            j++;
          }      
        }
      }
    }, false);
  }
}
</script>

  </head>

  <body>
    <div id="header-canvas">
       <canvas id='cv' width='640' height='360'>
         <div id='main-header'>
           <h1>The Stylogical Map</h1>
           <h4>A presentation of various works-in-progress, 
           <br/>exploring the omni-media vortex of 
           <br/>space, time, love, and perception.</h4>
         </div>
       </canvas>
       <canvas id='can23' width='480' height='270' style="width:640px; height:360px; image-rendering:optimizespeed ! important;"></canvas>
    </div>
	<div id="play_controls" style="width:100%">
		<a href="javascript:recordGIF ()">Record GIF</a>
		<p class="menulinkleft"><a href="intro.-01.html">&lt;&lt;</a></p>
		<p class="menulinkright"><a href="intro.-03.html">&gt;&gt;</a></p>
	</div>

    <p id="vstatus"></p>
	<p id="license" style="color:#fff">
		<img src="http://i.creativecommons.org/l/by-sa/3.0/nz/88x31.png" alt="Creative Commons Licence"><br />
		<em>These demos by <a href="mailto:revlin@uni-sol.org">Revlin John </a> are licensed under the <a href="http://creativecommons.org/licenses/by-sa/3.0/nz/deed.en_GB">Creative Commons Attribution-ShareAlike 3.0 License, 2009-2012 </a></em>
	</p>

	<div id="stream">
		<a href="http://www.archive.org/download/TheNewRead/Reveling_John_-_The_New_Read.mp3"><audio id="invisible10" autoplay="true" style="visibility: hidden; display:none;" preload="auto"><source src="http://www.archive.org/download/TheNewRead/Reveling_John_-_The_New_Read.mp3" /> <source src="http://www.archive.org/download/TheNewRead/Reveling_John_-_The_New_Read.ogg" /> <object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="640" height="26"><param value="true" name="allowfullscreen"><param value="always" name="allowscriptaccess"><param value="high" name="quality"><param value="true" name="cachebusting"><param value="#000000" name="bgcolor"><param name="movie" value="http://www.archive.org/flow/flowplayer.commercial-3.2.1.swf"><param value="config={'key':'#$aa4baff94a9bdcafce8','playlist':[{'url':'Reveling_John_-_The_New_Read.mp3','autoPlay':false}],'clip':{'autoPlay':true,'baseUrl':'http://www.archive.org/download/TheNewRead'},'canvas':{'backgroundColor':'#000000','backgroundGradient':'none'},'plugins':{'audio':{'url':'http://www.archive.org/flow/flowplayer.audio-3.2.1-dev.swf'},'controls':{'playlist':false,'fullscreen':false,'height':26,'backgroundColor':'#000000','autoHide':{'fullscreenOnly':true},'scrubberHeightRatio':0.6,'timeFontSize':9,'mute':false,'top':0}},'contextMenu':[{},'-','Flowplayer v3.2.1']}" name="flashvars"></object></audio></a><a href="http://www.archive.org/download/PhilipKDickSpeechExcerpts/PhilipKDick_1977.mp4"><video id="vid1" style="visibility: hidden; display: none;" preload="auto"><source src="http://www.archive.org/download/PhilipKDickSpeechExcerpts/PhilipKDick_1977.mp4" /><source src="http://www.archive.org/download/PhilipKDickSpeechExcerpts/PhilipKDick_1977.ogv" /><iframe src="http://www.youtube.com/embed/jXeVgEs4sOo"></iframe></video></a>
	</div>

<script src='scripts/processing-1.0.0.js' type='text/javascript'></script>
<script type='text/javascript'>/*<![CDATA[*/  /*Initiate Processing.js*/ init_processing(); /*]]>*/</script>
<script type="application/processing" target='can23'>/*<![CDATA[*/ /* Circus Fluid Made by Jared "BlueThen" C. on June 5th, 2011. Updated June 7th, 2011 (Commenting, refactoring, coloring changes) www.bluethen.com www.twitter.com/BlueThen www.openprocessing.org/portal/?userID=3044 www.hawkee.com/profile/37047/ Feel free to email me feedback, criticism, advice, job offers at: bluethen (@) gmail.com */ /* Frame rate control */ float div1000; byte frate; /* Variables for the timeStep */ long previousTime; long currentTime; float timeScale = .3; /* Play with this to slow down or speed up the fluid (the higher, the faster) */ final int fixedDeltaTime = (int)(10 / timeScale); float fixedDeltaTimeSeconds = (float)fixedDeltaTime / 1000; float leftOverDeltaTime = 0; /* The grid for fluid solving */ GridSolver grid; void setup () { size(240, 150, P2D); frate = 24; div1000 = (1000/frate); frameRate(frate*2); colorMode(HSB, 127); noStroke(); /* grid = new GridSolver(integer cellWidth) */ grid = new GridSolver(6); } void draw () { /* Frame rate control of Iteration */ short time = (short)(millis() % 1000); if(div1000 >= (time % (int)div1000)) { /* The ripple size will be determined by mouse speed */ float force = dist(mouseX, mouseY, pmouseX, pmouseY) * 255; /* This is bresenham's line algorithm // http://en.wikipedia.org/wiki/Bresenham's_line_algorithm // Instead of plotting points for a line, we create a ripple for each pixel between the // last cursor pos and the current cursor pos */ float dx = abs(mouseX - pmouseX); float dy = abs(mouseY - pmouseY); float sx; float sy; if (pmouseX < mouseX) sx = 1; else sx = -1; if (pmouseY < mouseY) sy = 1; else sy = -1; float err = dx - dy; float x0 = pmouseX; float x1 = mouseX; float y0 = pmouseY; float y1 = mouseY; while ( (x0 != x1) || (y0 != y1)) { /* Make sure the coordinate is within the window */ if (((int)(x0 / grid.cellSize) < grid.density1.length) && ((int)(y0 / grid.cellSize) < grid.density1[0].length) && ((int)(x0 / grid.cellSize) > 0) && ((int)(y0 / grid.cellSize) > 0)) grid.velocity[(int)(x0 / grid.cellSize)][(int)(y0 / grid.cellSize)] += force; float e2 = 2 * err; if (e2 > -dy) { err -= dy; x0 = x0 + sx; } if (e2 < dx) { err = err + dx; y0 = y0 + sy; } } } /* End of Iteration */ /******** Physics ********/ /* time related stuff */ /* Calculate amount of time since last frame (Delta means "change in") */ currentTime = millis(); long deltaTimeMS = (long)((currentTime - previousTime)); previousTime = currentTime; /* reset previousTime */ /* timeStepAmt will be how many of our fixedDeltaTimes we need to make up for the passed time since last frame. */ int timeStepAmt = (int)(((float)deltaTimeMS + leftOverDeltaTime) / (float)(fixedDeltaTime)); /* If we have any left over time left, add it to the leftOverDeltaTime.*/ leftOverDeltaTime += deltaTimeMS - (timeStepAmt * (float)fixedDeltaTime); if (timeStepAmt > 15) { timeStepAmt = 15; /* too much accumulation can freeze the program! */ /* println("Time step amount too high"); */} /* Update physics */ for (int iteration = 1; iteration <= timeStepAmt; iteration++) { grid.solve(fixedDeltaTimeSeconds * timeScale); } grid.draw(); /*println(frameRate);*/ } /* If the user clicks instead of drags the mouse, we create a ripple at one spot. */ void mouseClicked () { float force = 250000; if (((int)(mouseX / grid.cellSize) < grid.density1.length) && ((int)(mouseY / grid.cellSize) < grid.density1[0].length) && ((int)(mouseX / grid.cellSize) > 0) && ((int)(mouseY / grid.cellSize) > 0)) { grid.velocity[(int)(mouseX / grid.cellSize)][(int)(mouseY / grid.cellSize)] += force; } } /* GridSolver Class Velocity: How fast each pixel is moving up or down Density: How much "fluid" is in each pixel. *note* Density isn't conserved as far as I know. Changing the velocity ends up changing the density too. */ class GridSolver { int cellSize; /* Use 2 dimensional arrays to store velocity and density for each pixel. */ /* To access, use this: grid[x/cellSize][y/cellSize] */ float [][] velocity; float [][] density1; float [][] oldVelocity; float [][] oldDensity; int sx; int sy; float friction = 0.58; float speed = 20; /* Constructor */ GridSolver (int sizeOfCells) { cellSize = sizeOfCells; sx = int(width/cellSize); sy = int(height/cellSize); velocity = new float[sx][sy]; density1 = new float[sx][sy]; } /* Drawing */ void draw () { for (int x = 0; x < velocity.length; x++) { for (int y = 0; y < velocity[x].length; y++) { /* Sine probably isn't needed, but oh well. It's pretty and looks more organic. */ fill(127 + 127 * sin(density1[x][y]*0.0004), 255, 127 + 127 * sin(velocity[x][y]*0.01)); rect(x*cellSize, y*cellSize, cellSize, cellSize); } } } /* "Fluid" Solving Based on http://www.cs.ubc.ca/~rbridson/fluidsimulation/GameFluids2007.pdf To help understand this better, imagine each pixel as a spring. Every spring pulls on springs adjacent to it as it moves up or down (The speed of the pull is the Velocity) This pull flows throughout the window, and eventually deteriates due to friction */ void solve (float timeStep) { /* Reset oldDensity and oldVelocity */ /* oldDensity = (float[][])density1.clone(); */ oldDensity = new float[sx][sy]; for (int i=0; i < sx; i++ ) { for (int j=0; j < sy; j++ ) { oldDensity[i][j] = density1[i][j]; } } /* oldVelocity = (float[][])velocity.clone(); */ oldVelocity = new float[sx][sy]; for (int i=0; i < sx; i++ ) { for (int j=0; j < sy; j++ ) { oldVelocity[i][j] = velocity[i][j]; } } for (int x = 0; x < velocity.length; x++) { for (int y = 0; y < velocity[x].length; y++) { /* Equation for each cell: Velocity = oldVelocity + (sum_Of_Adjacent_Old_Densities - oldDensity_Of_Cell * 4) * timeStep * speed) Density = oldDensity + Velocity Scientists and engineers: Please don't use this to model tsunamis, I'm pretty sure it's not *that* accurate */ velocity[x][y] = friction * oldVelocity[x][y] + ((getAdjacentDensitySum(x,y) - density1[x][y] * 4) * timeStep * speed); density1[x][y] = oldDensity[x][y] + velocity[x][y]; } } } float getAdjacentDensitySum (int x, int y) { /* If the x or y is at the boundary, use the closest available cell */ float sum = 0; if (x-1 > 0) sum += oldDensity[x-1][y]; else sum += oldDensity[0][y]; if (x+1 <= oldDensity.length-1) sum += (oldDensity[x+1][y]); else sum += (oldDensity[oldDensity.length-1][y]); if (y-1 > 0) sum += (oldDensity[x][y-1]); else sum += (oldDensity[x][0]); if (y+1 <= oldDensity[x].length-1) sum += (oldDensity[x][y+1]); else sum += (oldDensity[x][oldDensity[x].length-1]); return sum; } } /*]]>*/</script>
 
<script type="text/javascript" src="jsgif/LZWEncoder.js"></script>
<script type="text/javascript" src="jsgif/NeuQuant.js"></script>
<script type="text/javascript" src="jsgif/GIFEncoder.js"></script>
<script type="text/javascript" src="jsgif/b64.js"></script>
<script type='text/javascript' src='scripts/mapscripts.js'></script>

  </body>
</html> 
